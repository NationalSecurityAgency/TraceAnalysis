#![allow(dead_code)]
use trace::index::spacetime_index::SpacetimeRTree;
use trace::index::Serializable;
use trace::reader::{cont, try_break, try_cont, TraceReader};
use trace::record::{parse_unknown, Record, RecordKind};
use trace::RuntimeError;

use anyhow::Error;
use anyhow::Result;
use clap::Parser;
use dataflow::address::SpaceKind;
use gdbstub::stub::GdbStub;
use std::collections::{BTreeMap, BTreeSet, HashMap};
use std::fs;
use std::io::Read;
use std::net::TcpListener;
use std::ops::ControlFlow;
use tracing::info;
use tracing_subscriber::{filter::LevelFilter, fmt, prelude::*, EnvFilter};

mod gdb;
use gdb::TraceX64Target;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Path to a file containing trace records from one run of the target program
    #[arg()]
    trace: String, // FIXME: this could be allowed to be stdin?

    /// Path to a file containing at least a register spacetime index + a memory spacetime index
    #[arg()]
    index: String, // FIXME: this can be optional, since tracefile is required

    /// Path to the `maps.out` file generated by tracing tools.
    #[arg(short, long)]
    mappings: Option<String>,

    /// A folder containing all the files referenced in the `mappings` argument. This folder will be used as the base for looking up libraries to load.
    #[arg(requires = "mappings", short, long)]
    sysroot: Option<String>,

    /// Address used for gdbserver connections
    #[arg(short, long, default_value_t = String::from("127.0.0.1"))]
    addr: String,

    /// Port number used for gdbserver connections
    #[arg(short, long, default_value_t = 9999)]
    port: u16,
}

fn main() -> Result<()> {
    let args = Args::parse();

    // Setup Logging
    tracing_subscriber::registry()
        .with(fmt::layer().without_time().compact()) // stdout_log
        .with(
            EnvFilter::builder()
                .with_default_directive(LevelFilter::INFO.into())
                .from_env_lossy(),
        )
        .init();

    info!("Parsing trace file...");
    let (pc_ticks_map, tick_pc_map) = parse_trace_file(&args.trace)?;
    info!("Parsing/creating index file...");
    let (reg_space, mem_space) = get_spaces_from_st_index(&args.index)?;

    let target = TraceX64Target::new(
        pc_ticks_map,
        tick_pc_map,
        reg_space,
        mem_space,
        args.mappings.unwrap_or(String::from("")),
        args.sysroot.unwrap_or(String::from("")),
    );
    let address = format!("{}:{}", args.addr, args.port);
    let listener = TcpListener::bind(&address)?;
    info!("Server listening at: {address}");
    let (conn, remote) = listener.accept()?;
    info!("Received connection from: {remote}");

    gdb::server::gdb_event_loop_thread(GdbStub::new(Box::new(conn)), target);

    Ok(())
}

/// Takes in a path to a trace file, parses it and returns:
///   - a [`HashMap<S, T>`] with a mapping from the addresses of instructions
///     (i.e. `u64`'s) to the tick values in the trace when those instructions
///     were ran.
///   - a ['BTreeMap<S, T>`] with a mapping from tick value to the corresponding
///     pc at that tick
fn parse_trace_file(trace: &str) -> Result<(HashMap<u64, BTreeSet<u64>>, BTreeMap<u64, u64>)> {
    let mut trace = TraceReader::new(Box::new(fs::File::open(trace)?));

    let raw = trace.next().ok_or(RuntimeError::MissingMagic)?;
    if Record::Magic != raw.parse(parse_unknown)? {
        return Err(RuntimeError::MissingMagic.into());
    }

    let raw = trace.next().ok_or(RuntimeError::MissingArch)?;
    let Record::Arch(arch) = raw.parse(parse_unknown)? else {
        return Err(RuntimeError::MissingArch.into());
    };

    let mut hashmap = HashMap::new();
    let mut btreemap = BTreeMap::new();
    let mut current_tick = 0;

    tracing::info!("Parsing Trace File...");
    trace.for_each(|raw| -> ControlFlow<Error> {
        let kind = try_cont!(raw.kind());
        match kind {
            RecordKind::Pc => {
                let record = try_break!(arch.parse_record(raw));
                if let Record::Pc(pc) = record {
                    current_tick += 1;
                    match btreemap.insert(current_tick, pc.pc()) {
                        Some(old_pc) => {
                            tracing::warn!(
                                "({}, {}) replaced by ({}, {}) in tick->pc mapping!",
                                current_tick,
                                old_pc,
                                current_tick,
                                pc.pc(),
                            );
                        }
                        None => {}
                    };
                }
                cont!();
            }
            RecordKind::Instruction => {
                let record = try_break!(arch.parse_record(raw));
                if let Record::Instruction(ins) = record {
                    hashmap
                        .entry(ins.pc())
                        .or_insert(BTreeSet::new())
                        .insert(current_tick);
                };
                cont!();
            }
            _ => {
                cont!();
            }
        }
    });

    Ok((hashmap, btreemap))
}

/// Returns a tuple of (reg_space, mem_space)
fn get_spaces_from_st_index(index: &str) -> Result<(SpacetimeRTree, SpacetimeRTree)> {
    let buffer = match index {
        "-" => {
            let mut _buffer = Vec::new();
            std::io::stdin().read_to_end(&mut _buffer)?;
            _buffer
        }
        _ => fs::read(index)?,
    };

    let mut offs = 0;

    let (mut reg_space, mut mem_space) = (None, None);
    while offs < buffer.len() {
        let tree = SpacetimeRTree::deserialize(&buffer[..], &mut offs);
        match tree.kind() {
            SpaceKind::Register => reg_space = Some(tree),
            SpaceKind::Memory => mem_space = Some(tree),
            _ => {}
        }
    }

    match (reg_space, mem_space) {
        (Some(r), Some(m)) => Ok((r, m)),
        _ => Err(anyhow::anyhow!(
            "Not enough 'spaces' in index file! (needs at least 2)"
        )),
    }
}
