use std::cell::RefCell;
use std::fs::File;
use std::io::{BufWriter, Write};
use std::rc::Rc;

use icicle_cpu::lifter::InstructionSource;
use icicle_cpu::{BlockGroup, BlockTable, Cpu, HookHandler};
use icicle_vm::{CodeInjector, Vm};

use trace::record::{self, Record};

///
/// Represents information relating to an ongoing program trace.
///
/// Developers should not directly instantiate this struct; instead, an instance
/// should be acquired via [TraceInjector::attach_to_vm];
///
// The information contained in this structure may be flushed to disk via a call
// to [TraceInfo::flush]. This occurs automatically.
//
pub struct TraceInfo {
    /// The file to which Trace information will be written
    file: BufWriter<File>,

    /// The internal byte steam containing Trace information. This should not
    /// be directly accessed; developers should acquire a reference via
    /// [TraceInfo::get_stream].
    trace: Vec<u8>,

    ///
    /// Though `reg_mapping` is implemented as a [Vec], it is treated more as
    /// a hashmap through which icicle register *id*s can be translated to
    /// sleigh register *numbers*.
    ///
    /// Icicle implements the register bank as a large array, and each register
    /// references a 16 byte range within the array. For this reason, the devs
    /// remapped the sleigh register numbers (which could potentially be very
    /// sparse) to sequential register IDs.
    ///
    /// As the Trace specification requires register numbers, we need to be
    /// able to quickly translate register IDs to register numbers. As indexing
    /// into a [Vec] is faster than a hashmap lookup, and the whole point of
    /// icicle's translation is to make register IDs sequentially index from
    /// zero, I implemented this translation with a [Vec], where
    /// `reg_mapping[id] = num` indicates that a register whose icicle
    /// representation has an id of `id` is represented by `sleigh` as register
    /// number `num`.
    ///
    reg_mapping: Vec<u32>,
}

impl TraceInfo {
    /// Flushes the cached Trace stream to disk.
    fn flush(&mut self) {
        let trace_data: &[u8] = &self.trace;
        let _ = self.file.write_all(trace_data);
        self.trace.clear();
    }

    fn get_stream<'a>(&'a mut self) -> &'a mut Vec<u8> {
        if self.trace.len() > 0x10000 {
            self.flush();
        }

        return &mut self.trace;
    }
}

impl Drop for TraceInfo {
    /// Implementation of [drop] ensures data is flushed before the [TraceInfo]
    /// is destroyed.
    fn drop(&mut self) {
        self.flush();
    }
}

///
/// See [TraceHooks] for an explanation of hooking.
///
/// This type implements a hook that, when called, generates a [PC](Record::Pc)
/// record according to instruction info generated by the instructions added by
/// [push_insn_info].
///
/// # Example
///
/// The following demonstrates how code making use of this hook can be
/// generated.
///
/// ```ignore
/// if pcode::Op::InstructionMarker == instruction.op {
///     let (insn_addr, insn_len) = parse_insn_info(instruction);
///     push_insn_info(&mut generated_block, insn_addr, insn_len);
///     generated_block.push(pcode::Op::Hook(registered_insn_start_hook));
/// }
///
/// // ...
///
/// generated_block.push(instruction);
///
/// // ...
/// ```
///
struct TraceInsnStartHook {
    /// A reference to the [TraceInfo] to which this hook should add relevant
    /// Trace information. All hooks should generally reference the same
    /// [TraceInfo].
    trace_info: Rc<RefCell<TraceInfo>>,
}

impl HookHandler for TraceInsnStartHook {
    fn call(data: &mut Self, cpu: &mut Cpu, _addr: u64) {
        let (insn_addr, _insn_len) = pop_insn_info(cpu);

        let pc_record = record::Pc::new(insn_addr);
        let record = Record::Pc(pc_record);

        record.emit(
            &mut data.trace_info.borrow_mut().get_stream(),
            record::emit_le64,
        );
    }
}

///
/// See [TraceHooks] for an explanation of hooking.
///
/// This type implements a hook that, when called, generates an
/// [instruction](Record::Instruction) record according to instruction info
/// generated by the instructions added by [push_insn_info].
///
/// A call to this hook should be added after all PCODE instructions implementing
/// a particular EMULATED instruction have been processed. See
/// [TraceInjector::inject] for an example.
///
struct TraceInsnEndHook {
    /// A reference to the [TraceInfo] to which this hook should add relevant
    /// Trace information. All hooks should generally reference the same
    /// [TraceInfo].
    trace_info: Rc<RefCell<TraceInfo>>,
}

impl HookHandler for TraceInsnEndHook {
    fn call(data: &mut Self, cpu: &mut Cpu, _addr: u64) {
        let (insn_addr, insn_len) = pop_insn_info(cpu);

        let mut insn_bytes = [0u8; 16];
        cpu.read_bytes(insn_addr, &mut insn_bytes);

        let insn_record = record::Instruction::new(insn_addr, &insn_bytes[..insn_len as usize]);

        let record = Record::Instruction(insn_record);

        record.emit(
            &mut data.trace_info.borrow_mut().get_stream(),
            record::emit_le64,
        );
    }
}

///
/// See [TraceHooks] for an explanation of hooking.
///
/// This type implements a hook that, when called, generates an
/// [register read](Record::RegRead) record according to instruction info
/// generated by the instructions added by [push_register_value]. Both the
/// instruction calling this hook and the instructions generated by
/// [push_register_value] should be added before the instruction being traced
/// to ensure that if the instruction also changes the register (such as in
/// the case of the instruction `r6:8 = [r6:8]`), the value read from the
/// register is properly recorded.
///
/// # Example
///
/// The following demonstrates how code making use of this hook can be
/// generated.
///
/// ```ignore
/// if let pcode::Value::Var(reg_read) = instruction.inputs.first() {
///     push_register_value(&mut generated_block, &reg_read, 0);
///     generated_block.push(pcode::Op::Hook(registered_reg_read_hook));
/// }
///
/// // ...
///
/// generated_block.push(instruction);
///
/// // ...
/// ```
///
struct TraceRegReadHook {
    /// A reference to the [TraceInfo] to which this hook should add relevant
    /// Trace information. All hooks should generally reference the same
    /// [TraceInfo].
    trace_info: Rc<RefCell<TraceInfo>>,
}

impl HookHandler for TraceRegReadHook {
    fn call(data: &mut Self, cpu: &mut Cpu, _addr: u64) {
        let (reg, reg_val) = pop_register_value(cpu);
        let reg_num = get_reg_num(&data.trace_info.borrow(), &reg);

        let reg_val_bytes = u64::to_le_bytes(reg_val);
        let reg_read_record = record::RegRead::new(reg_num, &reg_val_bytes[..reg.size as usize]);
        let record = Record::RegRead(reg_read_record);

        record.emit(
            &mut data.trace_info.borrow_mut().get_stream(),
            record::emit_le64,
        );
    }
}

///
/// See [TraceHooks] for an explanation of hooking.
///
/// This type implements a hook that, when called, generates an
/// [register write](Record::RegWrite) record according to instruction info
/// generated by the instructions added by [push_register_value]. Both the
/// instruction calling this hook and the instructions generated by
/// [push_register_value] should be added after the instruction being traced
/// to ensure that it is the new value of the register being recorded.
///
/// # Example
///
/// The following demonstrates how code making use of this hook can be
/// generated.
///
/// ```ignore
/// // ...
///
/// generated_block.push(instruction);
///
/// // ...
///
/// if !instruction.output.is_invalid() {
///     push_register_value(&mut generated_block, &instruction.output, 0);
///     generated_block.push(pcode::Op::Hook(registered_reg_write_hook));
/// }
/// ```
///
struct TraceRegWriteHook {
    /// A reference to the [TraceInfo] to which this hook should add relevant
    /// Trace information. All hooks should generally reference the same
    /// [TraceInfo].
    trace_info: Rc<RefCell<TraceInfo>>,
}

impl HookHandler for TraceRegWriteHook {
    fn call(data: &mut Self, cpu: &mut Cpu, _addr: u64) {
        let (reg, reg_val) = pop_register_value(cpu);
        let reg_num = get_reg_num(&data.trace_info.borrow(), &reg);

        let reg_val_bytes = u64::to_le_bytes(reg_val);
        let reg_write_record = record::RegWrite::new(reg_num, &reg_val_bytes[..reg.size as usize]);
        let record = Record::RegWrite(reg_write_record);

        record.emit(
            &mut data.trace_info.borrow_mut().get_stream(),
            record::emit_le64,
        );
    }
}

///
/// See [TraceHooks] for an explanation of hooking.
///
/// This type implements a hook that, when called, generates an
/// [memory read](Record::MemRead) record according to information recorded
/// in the CPU state by a series of three [pcode::Op::Arg] instructions
/// documented below.
///
/// The first [pcode::Op::Arg] should be `(pcode::Op::Arg(0), address)`, where
/// `address` is a [pcode::Value] describing the address from which memory is
/// being read. This instruction should be added *immediately before* the emulated
/// instruction so that in the case of instructions who overwrite the value
/// containing the address (i.e. `r6:8 = [r6:8]`), the address is still available
/// to the hook.
///
/// The second [pcode::Op::Arg] should be `(pcode::Op::Arg(1), value)`, where
/// `value` is a [pcode::Value] describing the data that was read from memory.
/// This instruction should be added *immediately after* the emulated instruction
/// so that the data read from memory is in the requested [pcode::Value].
///
/// The final [pcode::Op::Arg] should be `(pcode::Op::Arg(2), len)`, where `len`
/// is a [u8] equal to the number of bytes read from memory.
///
/// There are two reasons I decided to require that both the address and the
/// memory being read be recorded via [pcode::Op::Arg] instructions:
///
///  1. While icicle is single threaded right now, it is conceivable that a
///     multithreaded version may eventually be developed. In such a case,
///     it would be possible for the value this hook read from memory be
///     different from the value read from memory by the instruction itself.
///     There is also the case of memory mapped IO, for which a memory read
///     may result in the memory changing.
///
///  2. An eventual future optimization would involve doing away with these
///     hooks and instead inserting assembly that directly appends instruction
///     information to some global data stream. To that end, ensuring that each
///     hook can completely generate all Trace information strictly from args
///     (i.e. without requiring register or memory state information) would allow
///     for these same hook routines to be used to process that data stream into
///     a Trace file at some later point in time.
///
/// # Example
///
/// ```ignore
/// // ...
///
/// if let pcode::Op::Load(_) = instruction {
///     generated_block.push((pcode::Op::Arg(0), instruction.inputs.first()));
///     generated_block.push(instruction);
///     generated_block.push((pcode::Op::Arg(1), instruction.output));
///     generated_block.push((pcode::Op::Arg(2), instruction.output.size));
///     generated_block.push(pcode::Op::Hook(registered_mem_read_hook));
/// }
///
/// // ...
/// ```
///
struct TraceMemReadHook {
    /// A reference to the [TraceInfo] to which this hook should add relevant
    /// Trace information. All hooks should generally reference the same
    /// [TraceInfo].
    trace_info: Rc<RefCell<TraceInfo>>,
}

impl HookHandler for TraceMemReadHook {
    fn call(data: &mut Self, cpu: &mut Cpu, _addr: u64) {
        let (addr, bytes, len) = pop_mem_value(cpu);

        let mem_read_record = record::MemRead::new(addr, &bytes[..len as usize]);
        let record = Record::MemRead(mem_read_record);

        record.emit(
            &mut data.trace_info.borrow_mut().get_stream(),
            record::emit_le64,
        );
    }
}

///
/// See [TraceHooks] for an explanation of hooking.
///
/// This type implements a hook that, when called, generates an
/// [memory read](Record::MemWrite) record according to information recorded
/// in the CPU state by a series of three [pcode::Op::Arg] instructions
/// documented below.
///
/// The first [pcode::Op::Arg] should be `(pcode::Op::Arg(0), address)`, where
/// `address` is a [pcode::Value] describing the address to which data is
/// being written.
///
/// The second [pcode::Op::Arg] should be `(pcode::Op::Arg(1), value)`, where
/// `value` is a [pcode::Value] describing the data to be written to memory.
///
/// The final [pcode::Op::Arg] should be `(pcode::Op::Arg(2), len)`, where `len`
/// is a [u8] equal to the number of bytes written to memory.
///
/// There are two reasons I decided to require that both the address and the
/// memory being written be recorded via [pcode::Op::Arg] instructions rather
/// than just reading the memory after the write occurs:
///
///  1. While icicle is single threaded right now, it is conceivable that a
///     multithreaded version may eventually be developed. In such a case,
///     it would be possible for the value this hook read from memory be
///     different from the value written to memory by the instruction itself.
///     There is also the case of memory mapped IO, for which a memory read
///     may result in the memory changing.
///
///  2. An eventual future optimization would involve doing away with these
///     hooks and instead inserting assembly that directly appends instruction
///     information to some global data stream. To that end, ensuring that each
///     hook can completely generate all Trace information strictly from args
///     (i.e. without requiring register or memory state information) would allow
///     for these same hook routines to be used to process that data stream into
///     a Trace file at some later point in time.
///
/// # Example
///
/// ```ignore
/// // ...
///
/// if let pcode::Op::Store(_) = instruction {
///     generated_block.push((pcode::Op::Arg(0), instruction.inputs.first()));
///     generated_block.push((pcode::Op::Arg(1), instruction.output));
///     generated_block.push((pcode::Op::Arg(2), instruction.output.size));
///     generated_block.push(pcode::Op::Hook(registered_mem_write_hook));
///     generated_block.push(instruction);
/// }
///
/// // ...
/// ```
struct TraceMemWriteHook {
    /// A reference to the [TraceInfo] to which this hook should add relevant
    /// Trace information. All hooks should generally reference the same
    /// [TraceInfo].
    trace_info: Rc<RefCell<TraceInfo>>,
}

impl HookHandler for TraceMemWriteHook {
    fn call(data: &mut Self, cpu: &mut Cpu, _addr: u64) {
        let (addr, bytes, len) = pop_mem_value(cpu);

        let mem_write_record = record::MemWrite::new(addr, &bytes[..len as usize]);
        let record = Record::MemWrite(mem_write_record);

        record.emit(
            &mut data.trace_info.borrow_mut().get_stream(),
            record::emit_le64,
        );
    }
}

///
/// This is a container type for the various hooks required to capture Trace
/// information. As icicle requires ownership over instances of hook types
/// for those hooks to be registered, this type can only store the hook
/// instances before they are registered with icicle.
///
/// The hooks represented by an instance of [UnregisteredTraceHooks] can be
/// registered by calling [UnregisteredTraceHooks::register].
///
struct UnregisteredTraceHooks {
    /// A hook to be called when beginning to process an emulated instruction
    insn_start: TraceInsnStartHook,
    /// A hook to be called when finished processing an emulated instruction
    insn_end: TraceInsnEndHook,
    /// A hook to be called each time an emulated instruction reads from a
    /// register.
    reg_read: TraceRegReadHook,
    /// A hook to be called each time an emulated instruction writes to a
    /// register.
    reg_write: TraceRegWriteHook,
    /// A hook to be called each time an emulated instruction reads memory.
    mem_read: TraceMemReadHook,
    /// A hook to be called each time an emulated instruction writes to memory.
    mem_write: TraceMemWriteHook,
}

impl UnregisteredTraceHooks {
    ///
    /// Creates a new [UnregisteredTraceHooks] whose hooks all log to the
    /// [TraceInfo] referenced by `trace_info`.
    ///
    fn new(trace_info: Rc<RefCell<TraceInfo>>) -> Self {
        Self {
            insn_start: TraceInsnStartHook {
                trace_info: trace_info.clone(),
            },
            insn_end: TraceInsnEndHook {
                trace_info: trace_info.clone(),
            },
            reg_read: TraceRegReadHook {
                trace_info: trace_info.clone(),
            },
            reg_write: TraceRegWriteHook {
                trace_info: trace_info.clone(),
            },
            mem_read: TraceMemReadHook {
                trace_info: trace_info.clone(),
            },
            mem_write: TraceMemWriteHook {
                trace_info: trace_info.clone(),
            },
        }
    }

    ///
    /// Registers each of the hook routines with the specified CPU and produces
    /// a [RegisteredTraceHooks] to track their hook IDs.
    ///
    /// This moves `self` into `cpu`'s ownership.
    ///
    fn register(self, cpu: &mut Cpu) -> RegisteredTraceHooks {
        RegisteredTraceHooks {
            insn_start: cpu.add_hook(self.insn_start),
            insn_end: cpu.add_hook(self.insn_end),
            reg_read: cpu.add_hook(self.reg_read),
            reg_write: cpu.add_hook(self.reg_write),
            mem_read: cpu.add_hook(self.mem_read),
            mem_write: cpu.add_hook(self.mem_write),
        }
    }
}

///
/// This is a container type for the IDs of hooks required to capture Trace
/// information. As icicle requires ownership over instances of hook types
/// for those hooks to be registered, this type only has access to the IDs
/// by which hooks registered with icicle can be referenced.
///
/// An instance of this may be obtained by calling by calling
/// [UnregisteredTraceHooks::register].
///
struct RegisteredTraceHooks {
    /// The ID of the hook to be called when beginning to process an emulated
    /// instruction.
    insn_start: pcode::HookId,
    /// The ID of the hook to be called when finished processing an emulated
    /// instruction.
    insn_end: pcode::HookId,
    /// The ID of the hook to be called each time an emulated instruction reads
    /// from a register.
    reg_read: pcode::HookId,
    /// The ID of the hook to be called each time an emulated instruction writes
    /// to a register.
    reg_write: pcode::HookId,
    /// The ID of the hook to be called each time an emulated instruction reads
    /// memory.
    mem_read: pcode::HookId,
    /// The ID of the hook to be called each time an emulated instruction writes
    /// to memory.
    mem_write: pcode::HookId,
}

///
/// Represents and stores hooks used to generate Trace information.
///
/// Icicle allows developers to create an "injector" that gets an opportunity
/// to add PCODE instructions to each block of code as it is lifted. The approach
/// I use is to create an injector that, for each part of a PCODE instruction that
/// we care about, injects "hook" instructions.
///
/// These hook instructions tell both the interpreter and the JITed code to call
/// (rust) hook routines. Each hook routine is defined as a struct that implements
/// the [HookHandler] trait, and calling a hook routine is implemented as calling
/// [HookHandler::call], as defined for the particular hook type.
///
/// However, [HookHandler::call] does not have access to the PCODE instruction
/// it's instrumenting, so instead, when we inject the hook instruction, we also
/// have to inject several [pcode::Op::Arg] instructions, which, at runtime, store
/// data we control in the CPU state, which [HookHandler::call] *can* access.
///
/// Inserting a [pcode::Op::Hook] instruction requires a "hook ID", which is
/// obtained when an instance of a struct implementing the [HookHandler] trait
/// is passed to [Cpu::add_hook].
///
enum TraceHooks {
    /// See [UnregisteredTraceHooks].
    Unregistered(UnregisteredTraceHooks),
    /// See [RegisteredTraceHooks].
    Registered(RegisteredTraceHooks),
}

//
// A type that contains the relevant information and methods for injecting hooks
// as described in the documentation for [TraceHooks].
///
/// When initially instantiated, the [TraceInjector] is not associated with any
/// particular icicle runtime environment. It may be attached - and therefore told
/// to inject - to a particular icicle VM via [TraceInjector::attach_to_vm].
///
pub struct TraceInjector {
    /// A reference to the [TraceInfo] to which this hooks registered by this
    /// injector record Trace information.
    trace_info: Rc<RefCell<TraceInfo>>,
    /// A temporary [pcode::Block] used when rewriting blocks with injected code.
    tmp_block: pcode::Block,
    /// The hooks used by the injector. Before the injector is attached to a VM,
    /// the hooks will be unregistered. After the injector is attached, they will
    /// be registered.
    hooks: TraceHooks,
}

impl TraceInjector {
    ///
    /// Intantiates a [TraceInjector] and sets up hook routines such that the
    /// [TraceInfo] to which they log flushes to `./log.trace`.
    ///
    pub fn create_default() -> Self {
        let trace_path = std::env::var_os("ICICLE_TRACE_PATH").map_or_else(
            || std::path::PathBuf::from("./log.trace"),
            std::path::PathBuf::from,
        );

        TraceInjector::create_with_path(trace_path)
    }

    ///
    /// Intantiates a [TraceInjector] and sets up hook routines such that the
    /// [TraceInfo] to which they log flushes to the file specified by `path`.
    ///
    pub fn create_with_path(path: std::path::PathBuf) -> Self {
        let trace_info = Rc::new(RefCell::new(TraceInfo {
            file: BufWriter::new(File::create(path).unwrap()),
            trace: Vec::new(),
            reg_mapping: Vec::new(),
        }));

        Self {
            trace_info: trace_info.clone(),
            tmp_block: pcode::Block::new(),
            hooks: TraceHooks::Unregistered(UnregisteredTraceHooks::new(trace_info)),
        }
    }

    ///
    /// Attaches the [TraceInjector] to the specified icicle VM.
    ///
    /// This registers all relevant hook routines and tells the VM to inject
    /// hooks as relevant whenever blocks are lifted.
    ///
    /// This returns a reference to the [TraceInfo] to which dataflow
    /// information is logged.
    ///
    pub fn attach_to_vm(mut self, vm: &mut Vm) -> Rc<RefCell<TraceInfo>> {
        /* This has to be in a sub-scope so that `reg_nums` goes out of scope and
         * therefore loses its reference to `self` before we `vm.add_injector`. */
        {
            let reg_nums = &mut self.trace_info.borrow_mut().reg_mapping;
            for (reg_num, (reg_id, _offset)) in vm.cpu.arch.sleigh.register_mapping.iter() {
                let required_size = (reg_id + 1) as usize;
                if reg_nums.len() < required_size {
                    reg_nums.resize(required_size, 0xFFFFFFFF);
                }

                reg_nums[*reg_id as usize] = *reg_num;
            }
        }

        if let TraceHooks::Unregistered(unregistered_hooks) = self.hooks {
            self.hooks = TraceHooks::Registered(unregistered_hooks.register(&mut vm.cpu));
        }

        Record::Magic.emit(&mut self.trace_info.borrow_mut().trace, record::emit_le64);
        Record::Arch(match vm.cpu.arch.triple.architecture {
            target_lexicon::Architecture::X86_64 => trace::Arch::X86_64,
            _ => panic!("Unsupported architecture!"),
        })
        .emit(&mut self.trace_info.borrow_mut().trace, record::emit_le64);

        let trace_info = self.trace_info.clone();

        vm.add_injector(self);

        trace_info
    }
}

impl CodeInjector for TraceInjector {
    fn inject(&mut self, _cpu: &mut Cpu, group: &BlockGroup, code: &mut BlockTable) {
        if let TraceHooks::Registered(hooks) = &self.hooks {
            let (mut insn_addr, mut insn_len) = (0u64, 0u64);

            for id in group.range() {
                let block = &mut code.blocks[id];

                self.tmp_block.clear();
                self.tmp_block.next_tmp = block.pcode.next_tmp;

                for stmt in block.pcode.instructions.drain(..) {
                    /*
                     * There are 6 things we care about here:
                     *  1. When the EMULATED instruction starts
                     *  2. Which registers the EMULATED instruction reads
                     *  3. What memory the EMULATED instruction reads
                     *  4. Which register, if any, the EMULATED instruction updates
                     *  5. What memory, if any, the EMULATED instruction updates
                     *  6. When the EMULATED instruction ends.
                     *
                     * Each EMULATED instruction is implemented as 1 or more PCODE
                     * instructions. The lifting process offers us some guarantees:
                     *
                     *  - The series of PCODE instructions implementing the EMULATED
                     *    instruction always begins with an InstructionMarker PCODE
                     *    instruction.
                     *
                     *  - The InstructionMarker PCODE instruction has no register
                     *    output and has two constant inputs specify the address and
                     *    length of the EMULATED instruction.
                     *
                     *  - Any PCODE instruction implementing a memory read reads an
                     *    address stored in a register or specified by a constant.
                     *
                     *  - Any PCODE instruction implementing a memory write writes
                     *    to an address stored in a register or specified by a
                     *    constant.
                     *
                     * As the PCODE instructions implementing the EMULATED
                     * instructions always starts with an InstructionMarker, we
                     * can use this to both record the end of the previous
                     * instruction and the start of the next.
                     *
                     * For each EMULATED instruction, we want to generate code to,
                     * in order,
                     *
                     *  1. Trigger a callback indicating the previous instruction is
                     *     no longer being processed, if an instruction was already
                     *     being processed.
                     *
                     *  2. Trigger a callback indicating the current instruction
                     *     is now being processed.
                     *
                     *  3. Trigger a callback for each register being read, if
                     *     applicable.
                     *
                     *  4. Trigger a callback for the memory being read, if
                     *     applicable.
                     *
                     *  5. Implement the instruction itself.
                     *
                     *  6. Trigger a callback for each register to which data
                     *     was written.
                     *
                     *  7. Trigger a callback for any memory to which data was
                     *     written.
                     *
                     * However, there may be some weird architecture where a
                     * register is written to and then read from in the same
                     * instruction. To address this, we'll use the exact same
                     * order of operations above, except instead of performing
                     * steps 3 through 7 for the EMULATED instruction, we'll
                     * instead perform them for each PCODE instruction that makes
                     * up the EMULATED instruction.
                     */

                    if stmt.op == pcode::Op::InstructionMarker {
                        /* Check if we're the first instruction in the block before
                         * adding a callback to indicate the previous instruction is
                         * done. */
                        if insn_addr != 0 {
                            /* The hook doesn't have access to the instruction length,
                             * but to pass it to dataflow, we need to know how many
                             * bytes to read.
                             *
                             * The address received by the hook routine is the most
                             * recent address from an InstructionMarker from either
                             * JITed or interpreted PCODE instructions, which in this
                             * case, is the same as the `insn_addr` we're pushing.
                             * But I could potentially foresee some changes down the
                             * line that would require processing instructions out of
                             * line with the actual instruction that's being emulated,
                             * so for future developers' sake, I'm recording both
                             * the address and the length. */
                            push_insn_info(&mut self.tmp_block, insn_addr, insn_len);
                            self.tmp_block.push(pcode::Op::Hook(hooks.insn_end));
                        }

                        insn_addr = stmt.inputs.first().as_u64();
                        insn_len = stmt.inputs.second().as_u64();

                        /* The insn_start hook records the address of the next instruction
                         * to be processed, but we're putting the hook before the
                         * InstructionMarker PCODE instruction. As the InstructionMarker
                         * is what updates the address passed to the hook routine, if the
                         * hook routine naively uses that address, it will be wrong. We will
                         * instead pass the actual EMULATED instruction address ourselves.
                         *
                         * The length is not necessary for now, so it could be skipped. */
                        push_insn_info(&mut self.tmp_block, insn_addr, insn_len);
                        self.tmp_block.push(pcode::Op::Hook(hooks.insn_start));
                    }

                    if let pcode::Value::Var(reg_read) = stmt.inputs.first() {
                        if !reg_read.is_invalid() && !reg_read.is_temp() {
                            /* The hook routines don't have access to the PCODE instructions
                             * being instrumented, so unless we want to re-disassemble the
                             * code, we need to pass relevant information to the hook
                             * routine. */
                            push_register_value(&mut self.tmp_block, &reg_read);
                            self.tmp_block.push(pcode::Op::Hook(hooks.reg_read));
                        }
                    }

                    if let pcode::Value::Var(reg_read) = stmt.inputs.second() {
                        if !reg_read.is_invalid() && !reg_read.is_temp() {
                            push_register_value(&mut self.tmp_block, &reg_read);
                            self.tmp_block.push(pcode::Op::Hook(hooks.reg_read));
                        }
                    }

                    /* Some types of PCODE instructions require special handling with how and
                     * when hooks should run. Operation-specific logic follows... */
                    match stmt.op {
                        pcode::Op::Load(_) => {
                            /* We ought to be cognizant of race conditions, memory mapped IO,
                             * and other such weirdness; rather than reading the value of the
                             * memory (either before of after the PCODE instruction is executed),
                             * we should instead read the value of the register into which the
                             * memory was read AFTER the memory is read to it.
                             *
                             * This adds some complexity; we must consider instructions of the
                             * form `MOV RAX, [RAX]`, and if our hook only runs after the
                             * instruction, the address from which memory was read may have been
                             * clobbered.
                             *
                             * To resolve this, we will:
                             *
                             *  1. Add an instruction that records the address from which memory
                             *     is being read.
                             *
                             *  2. Add the PCODE instruction being emulated
                             *
                             *  3. Add an instruction that records the data read from the memory
                             *
                             *  4. Add the instruction that calls our hook routine.
                             *
                             * Instruction format: <register> = [<value>]
                             *
                             * The value in the LHS is the output, and the value in the
                             * RHS is the first input. */
                            self.tmp_block
                                .push((pcode::Op::Arg(0), stmt.inputs.first()));
                            self.tmp_block.push(stmt);
                            self.tmp_block.push((pcode::Op::Arg(1), stmt.output));
                            self.tmp_block.push((pcode::Op::Arg(2), stmt.output.size));
                            self.tmp_block.push(pcode::Op::Hook(hooks.mem_read));
                        }
                        pcode::Op::Store(_) => {
                            /* We ought to be cognizant of race conditions, memory mapped IO, and
                             * other such weirdness; rather than reading the value of memory after
                             * it's written, we ought to read the value being written to it.
                             *
                             *     Instruction format: [<value>] = <value>
                             *
                             * The value in the LHS is the "first" input, and the value in the
                             * RHS is the "second" input. Thus, we want to record the value of
                             * the second input as being stored in memory at the value of the
                             * first input. */
                            self.tmp_block
                                .push((pcode::Op::Arg(0), stmt.inputs.first()));
                            self.tmp_block
                                .push((pcode::Op::Arg(1), stmt.inputs.second()));
                            self.tmp_block
                                .push((pcode::Op::Arg(2), stmt.inputs.second().size()));
                            self.tmp_block.push(pcode::Op::Hook(hooks.mem_write));
                            self.tmp_block.push(stmt);
                        }
                        pcode::Op::Exception => {
                            /* Observed: after executing Exception PCODE instructions, subsequent
                             * PCODE instructions in the block do not run. I suspect what's
                             * happening is icicle's emulation of iret (or other architectures'
                             * syscall return) is resulting in the next instruction being treated
                             * as the start of a new block.
                             *
                             * The way I've set stuff up now, no data is translated across blocks,
                             * so if we want to record the instruction, we need to add the
                             * instruction end hook BEFORE the exception instruction gets run. */
                            if insn_addr != 0 {
                                push_insn_info(&mut self.tmp_block, insn_addr, insn_len);
                                self.tmp_block.push(pcode::Op::Hook(hooks.insn_end));

                                /* This tells the injector not to add the instruction end hook
                                 * later. */
                                insn_addr = 0;
                            }

                            self.tmp_block.push(stmt);
                        }
                        pcode::Op::Branch(_) | pcode::Op::PcodeBranch(_) => {
                            panic!("branches not supported!")
                        }
                        _ => self.tmp_block.push(stmt),
                    }

                    if !stmt.output.is_invalid() && !stmt.output.is_temp() {
                        push_register_value(&mut self.tmp_block, &stmt.output);
                        self.tmp_block.push(pcode::Op::Hook(hooks.reg_write));
                    }
                }

                code.modified.insert(id);

                /* We usually mark the end of an EMULATED instruction at the start of the next,
                 * but since we're at the end of the block, there is no next instruction. To
                 * handle this case, as long as the block had at least one instruction, we'll
                 * manually add a callback indicating the end of the EMULATED instruction. */

                if insn_addr != 0 {
                    push_insn_info(&mut self.tmp_block, insn_addr, insn_len);
                    self.tmp_block.push(pcode::Op::Hook(hooks.insn_end));
                }

                std::mem::swap(
                    &mut self.tmp_block.instructions,
                    &mut block.pcode.instructions,
                );
            }
        }
    }
}

///
/// This looks up the SLEIGH register number by icicle's representation of the
/// register using the lookup table stored in the provided [TraceInfo]. This
/// table is initialized when [TraceInjector::attach_to_vm] is called.
///
fn get_reg_num(trace_info: &TraceInfo, reg: &pcode::VarNode) -> u32 {
    trace_info.reg_mapping[reg.id as usize] + reg.offset as u32
}

///
/// This adds instructions to `block` that make `insn_addr` and `insn_len`
/// available to rust code that calls [pop_insn_info].
///
fn push_insn_info(block: &mut pcode::Block, insn_addr: u64, insn_len: u64) {
    block.push((pcode::Op::Arg(0), insn_addr));
    block.push((pcode::Op::Arg(1), insn_len));
}

///
/// Retrieves the `(instruction address, instruction length)` pushed by
/// instructions injected to a code block by [push_insn_info].
///
fn pop_insn_info(cpu: &mut Cpu) -> (u64, u64) {
    (cpu.args[0] as u64, cpu.args[1] as u64)
}

///
/// This adds instructions to `block` that make the register referenced by
/// `var_node` and the data it contains available to rust code that calls
/// [pop_register_value].
///
fn push_register_value(block: &mut pcode::Block, var_node: &pcode::VarNode) {
    block.push((pcode::Op::Arg(0), var_node.id));
    block.push((pcode::Op::Arg(1), var_node.offset));
    block.push((pcode::Op::Arg(2), var_node.size));
    block.push((pcode::Op::Arg(3), var_node.to_owned()));
}

///
/// Retrieves the `(register identifier, register value)` pushed by instructions
/// injected to a code block by [push_register_value].
///
fn pop_register_value(cpu: &mut Cpu) -> (pcode::VarNode, u64) {
    (
        pcode::VarNode {
            id: cpu.args[0] as i16,
            offset: cpu.args[1] as u8,
            size: cpu.args[2] as u8,
        },
        cpu.args[3] as u64,
    )
}

///
/// Retrieves the `(memory address, data, length)` pushed by instructions injected
/// to a code block by [TraceInjector::inject] when instrumenting a memory
/// operation.
///
fn pop_mem_value(cpu: &mut Cpu) -> (u64, [u8; 8], u8) {
    (
        cpu.args[0] as u64,                 // addr
        (cpu.args[1] as u64).to_le_bytes(), // data
        cpu.args[2] as u8,                  // size
    )
}
